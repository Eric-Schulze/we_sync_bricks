{{define "bricklink-item-scripts"}}
<script>
function togglePartsList(itemId) {
    const partsList = document.getElementById('parts-list-' + itemId);
    const toggleIcon = document.getElementById('toggle-icon-' + itemId);
    const toggleButton = document.getElementById('toggle-parts-' + itemId);
    
    if (partsList.style.display === 'none') {
        partsList.style.display = 'block';
        toggleIcon.textContent = '‚ñº';
        toggleButton.querySelector('span:nth-child(2)').textContent = 'Hide Parts List';
    } else {
        partsList.style.display = 'none';
        toggleIcon.textContent = '‚ñ∂';
        toggleButton.querySelector('span:nth-child(2)').textContent = 'Show Parts List';
    }
}

function loadMinifigDetails(itemId) {
    // Load all minifig details immediately after search results are displayed
    loadMinifigPicture(itemId);
    loadMinifigPricing(itemId);
    loadMinifigParts(itemId);
}

function loadMinifigPicture(itemId) {
    console.log('Loading picture for:', itemId);
    
    fetch('/partial-minifigs-lists/minifig-picture', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: 'bricklink_id=' + encodeURIComponent(itemId)
    })
    .then(response => response.json())
    .then(data => {
        console.log('Picture API response:', data);
        const pictureContainer = document.getElementById('picture-' + itemId);
        
        // Check if API call was successful
        if (data && data.meta && data.meta.code === 200 && data.data) {
            // Use the first image if available
            const firstImage = data.data;
            const imageUrl = firstImage.thumbnail_url || firstImage.url;
            if (imageUrl) {
                pictureContainer.innerHTML = '<img src="' + imageUrl + '" alt="Minifig ' + itemId + '" style="max-width: 100%; max-height: 100%; object-fit: contain; border-radius: 4px;">';
                // Ensure the container maintains its flex properties and force reflow
                pictureContainer.style.display = 'flex';
                pictureContainer.style.alignItems = 'center';
                pictureContainer.style.justifyContent = 'center';
                pictureContainer.offsetHeight;
            } else {
                pictureContainer.innerHTML = '<div style="text-align: center; color: #9ca3af;"><div style="font-size: 1.5rem;">üì∑</div><div style="font-size: 0.75rem;">No URL</div></div>';
            }
        } else {
            const errorMsg = data && data.meta ? data.meta.message : 'Unknown error';
            console.log('Picture API error:', errorMsg);
            pictureContainer.innerHTML = '<div style="text-align: center; color: #9ca3af;"><div style="font-size: 1.5rem;">üì∑</div><div style="font-size: 0.75rem;">No image</div></div>';
        }
    })
    .catch(error => {
        console.error('Error loading picture:', error);
        document.getElementById('picture-' + itemId).innerHTML = '<div style="text-align: center; color: #ef4444;"><div style="font-size: 1.5rem;">‚ùå</div><div style="font-size: 0.75rem;">Error</div></div>';
    });
}

function loadMinifigPricing(itemId) {
    console.log('Loading pricing for:', itemId);
    
    // Load both new and used pricing in parallel
    Promise.all([
        loadMinifigPricingByCondition(itemId, 'N'),
        loadMinifigPricingByCondition(itemId, 'U')
    ])
    .then(([newPrice, usedPrice]) => {
        const priceNewElement = document.getElementById('price-new-' + itemId);
        const priceUsedElement = document.getElementById('price-used-' + itemId);
        
        // Update new price
        if (newPrice !== null && !isNaN(newPrice)) {
            priceNewElement.textContent = '$' + newPrice.toFixed(2);
        } else {
            priceNewElement.textContent = 'N/A';
        }
        
        // Update used price
        if (usedPrice !== null && !isNaN(usedPrice)) {
            priceUsedElement.textContent = '$' + usedPrice.toFixed(2);
        } else {
            priceUsedElement.textContent = 'N/A';
        }
        
        console.log('Final pricing - New:', newPrice, 'Used:', usedPrice);
    })
    .catch(error => {
        console.error('Error loading pricing:', error);
        document.getElementById('price-new-' + itemId).textContent = 'Error';
        document.getElementById('price-used-' + itemId).textContent = 'Error';
    });
}

function loadMinifigPricingByCondition(itemId, condition) {
    console.log('Loading', condition === 'N' ? 'new' : 'used', 'pricing for:', itemId);
    
    return fetch('/partial-minifigs-lists/minifig-pricing', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: 'bricklink_id=' + encodeURIComponent(itemId) + '&condition=' + encodeURIComponent(condition)
    })
    .then(response => response.json())
    .then(data => {
        console.log('Pricing API response for condition', condition, ':', data);
        
        // Check if API call was successful
        if (data && data.meta && data.meta.code === 200 && data.data) {
            // Handle both array and single object responses
            let priceItems = Array.isArray(data.data) ? data.data : [data.data];
            
            // Extract price from the first item (should match our condition)
            if (priceItems.length > 0) {
                const priceItem = priceItems[0];
                const avgPrice = priceItem.avg_price || priceItem.average_price || priceItem.price;
                
                if (avgPrice) {
                    const price = parseFloat(avgPrice);
                    console.log('Found', condition === 'N' ? 'new' : 'used', 'price:', price);
                    return price;
                }
            }
        } else {
            const errorMsg = data && data.meta ? data.meta.message : 'Unknown error';
            console.log('Pricing API error for condition', condition, ':', errorMsg);
        }
        
        return null;
    });
}

function loadMinifigParts(itemId) {
    console.log('Loading parts for:', itemId);
    
    fetch('/partial-minifigs-lists/minifig-parts', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: 'bricklink_id=' + encodeURIComponent(itemId)
    })
    .then(response => response.json())
    .then(data => {
        console.log('Parts API response:', data);
        const partsListElement = document.getElementById('parts-list-' + itemId);
        const toggleButton = document.getElementById('toggle-parts-' + itemId);
        const toggleStatus = toggleButton.querySelector('span:nth-child(3)');
        
        // Check if API call was successful
        if (data && data.meta && data.meta.code === 200 && data.data && data.data.length > 0) {
            console.log('Processing parts data:', data.data.length, 'parts');
            
            let partsHtml = '<div style="margin-bottom: 0.5rem; display: flex; align-items: center; justify-content: space-between;">';
            partsHtml += '<div style="font-weight: 600; color: #374151;">Parts (' + data.data.length + '):</div>';
            partsHtml += '<button type="button" id="select-all-' + itemId + '" onclick="toggleAllParts(\'' + itemId + '\')" style="background: none; border: 1px solid #d1d5db; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.75rem; color: #6b7280; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.backgroundColor=\'#f3f4f6\'" onmouseout="this.style.backgroundColor=\'transparent\'">Select All</button>';
            partsHtml += '</div>';
            data.data.forEach((part, index) => {
                console.log('Part', index + 1, ':', part);
                console.log('Part structure - item:', part.item, 'entries:', part.entries);
                
                // Try different possible structures for part data
                let partName = 'Unknown Part';
                let partQuantity = 1;
                let partNo = '';
                let colorId = null;
                let itemType = 'PART';
                
                // Check if it's a direct item structure
                if (part.item && part.item.name) {
                    partName = part.item.name;
                    partNo = part.item.no || '';
                    itemType = part.item.type || 'PART';
                    partQuantity = part.quantity || 1;
                    colorId = part.color_id || null;
                }
                // Check if it's in entries array
                else if (part.entries && part.entries.length > 0) {
                    const entry = part.entries[0];
                    if (entry.item && entry.item.name) {
                        partName = entry.item.name;
                        partNo = entry.item.no || '';
                        itemType = entry.item.type || 'PART';
                        partQuantity = entry.quantity || 1;
                        colorId = entry.color_id || null;
                    }
                }
                // Check if part data is directly on the object
                else if (part.name) {
                    partName = part.name;
                    partNo = part.no || '';
                    itemType = part.type || 'PART';
                    partQuantity = part.quantity || 1;
                    colorId = part.color_id || null;
                }
                
                console.log('Extracted - Name:', partName, 'No:', partNo, 'Type:', itemType, 'Qty:', partQuantity, 'Color ID:', colorId);
                
                const partId = `part-${index}-${itemId}`;
                
                partsHtml += '<div class="part-card part-card-' + itemId + '" id="' + partId + '-card" data-item-id="' + itemId + '" data-part-no="' + partNo + '" data-part-name="' + partName + '" data-quantity="' + partQuantity + '" data-color-id="' + colorId + '" data-item-type="' + itemType + '" onclick="togglePartCard(\'' + partId + '\', \'' + itemId + '\')" style="display: flex; align-items: center; padding: 0.75rem; margin-bottom: 0.5rem; border: 2px solid #e5e7eb; border-radius: 8px; cursor: pointer; transition: all 0.2s; background-color: white;" onmouseover="this.style.backgroundColor=\'#f8f9fa\'" onmouseout="if (!this.classList.contains(\'selected\')) this.style.backgroundColor=\'white\'">'
                
                // Part image placeholder
                partsHtml += '<div style="flex: 0 0 50px; margin-right: 1rem;">';
                partsHtml += '<div id="' + partId + '-image" style="width: 50px; height: 50px; background-color: #f8f9fa; border: 1px solid #e5e7eb; border-radius: 4px; display: flex; align-items: center; justify-content: center;">';
                partsHtml += '<div style="font-size: 1rem; color: #9ca3af;">üì¶</div>';
                partsHtml += '</div>';
                partsHtml += '</div>';
                
                // Part details
                partsHtml += '<div style="flex: 1;">';
                partsHtml += '<div style="font-weight: 500; margin-bottom: 0.25rem;">' + partName + '</div>';
                if (partNo) {
                    partsHtml += '<div style="font-size: 0.75rem; color: #6b7280;">ID: ' + partNo + '</div>';
                }
                // Add pricing display for individual parts
                partsHtml += '<div style="font-size: 0.7rem; color: #6b7280; margin-top: 0.25rem;">';
                partsHtml += 'New: <span id="' + partId + '-price-new" style="font-weight: 600;">Loading...</span> | ';
                partsHtml += 'Used: <span id="' + partId + '-price-used" style="font-weight: 600;">Loading...</span>';
                partsHtml += '</div>';
                partsHtml += '</div>';
                
                // Quantity
                partsHtml += '<span style="color: #6b7280; font-size: 0.75rem; margin-left: 0.5rem;">Qty: ' + partQuantity + '</span>';
                
                // Selection indicator
                partsHtml += '<div class="selection-indicator" style="margin-left: 0.75rem; width: 20px; height: 20px; border: 2px solid #d1d5db; border-radius: 4px; display: flex; align-items: center; justify-content: center; transition: all 0.2s;">';
                partsHtml += '<div class="checkmark" style="display: none; color: white; font-size: 0.75rem; font-weight: bold;">‚úì</div>';
                partsHtml += '</div>';
                
                partsHtml += '</div>';
                
                // Queue image and pricing loading if we have the part number
                if (partNo) {
                    // Use colorId if available, otherwise use 0
                    const actualColorId = colorId || 0;
                    
                    if (colorId) {
                        setTimeout(() => loadPartImage(partId, itemType, partNo, colorId), index * 100);
                    }
                    // Always try to load pricing with either the actual colorId or 0
                    setTimeout(() => loadPartPricing(partId, itemType, partNo, actualColorId, partQuantity, itemId), index * 100 + 50);
                }
            });
            partsListElement.innerHTML = partsHtml;
            toggleStatus.textContent = '(' + data.data.length + ' parts)';
            
            // Initialize part out values tracking
            window.partOutValues = window.partOutValues || {};
            window.partOutValues[itemId] = {
                newTotal: 0,
                usedTotal: 0,
                partsLoaded: 0,
                totalParts: data.data.filter(part => {
                    let partNo = '';
                    
                    if (part.item && part.item.no) {
                        partNo = part.item.no;
                    } else if (part.entries && part.entries.length > 0) {
                        partNo = part.entries[0].item && part.entries[0].item.no;
                    } else if (part.no) {
                        partNo = part.no;
                    }
                    
                    return partNo; // Only need part number, colorId can be 0
                }).length
            };
        } else {
            const errorMsg = data && data.meta ? data.meta.message : 'Unknown error';
            console.log('Parts API error:', errorMsg);
            partsListElement.innerHTML = '<div style="color: #9ca3af; text-align: center;">No parts data available</div>';
            toggleStatus.textContent = '(No parts)';
        }
        
        // Enable the toggle button and add button
        toggleButton.disabled = false;
        toggleButton.style.color = '#374151';
        
        // Enable the Add Minifig and Parts button
        const addButton = document.getElementById('add-minifig-' + itemId);
        if (addButton) {
            addButton.disabled = false;
        }
    })
    .catch(error => {
        console.error('Error loading parts:', error);
        document.getElementById('parts-list-' + itemId).innerHTML = '<div style="color: #ef4444; text-align: center;">Error loading parts</div>';
        const toggleButton = document.getElementById('toggle-parts-' + itemId);
        if (toggleButton) {
            const toggleStatus = toggleButton.querySelector('span:nth-child(3)');
            if (toggleStatus) {
                toggleStatus.textContent = '(Error)';
            }
        }
    });
}

function loadPartImage(partId, itemType, partNo, colorId) {
    console.log('Loading part image:', partId, itemType, partNo, colorId);
    
    fetch('/partial-minifigs-lists/part-picture', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: 'item_type=' + encodeURIComponent(itemType) + 
              '&item_id=' + encodeURIComponent(partNo) + 
              '&color_id=' + encodeURIComponent(colorId)
    })
    .then(response => response.json())
    .then(data => {
        console.log('Part image API response for', partId, ':', data);
        const imageContainer = document.getElementById(partId + '-image');
        
        if (data && data.meta && data.meta.code === 200 && data.data) {
            // Handle both array and single object responses
            let imageData = Array.isArray(data.data) ? data.data : [data.data];
            
            if (imageData.length > 0) {
                const firstImage = imageData[0];
                const imageUrl = firstImage.thumbnail_url || firstImage.url;
                
                if (imageUrl && imageContainer) {
                    imageContainer.innerHTML = '<img src="' + imageUrl + '" alt="Part ' + partNo + '" style="max-width: 100%; max-height: 100%; object-fit: contain; border-radius: 4px;">';
                    // Ensure container maintains its flex properties
                    imageContainer.style.display = 'flex';
                    imageContainer.style.alignItems = 'center';
                    imageContainer.style.justifyContent = 'center';
                } else {
                    console.log('No image URL found for part:', partId);
                }
            }
        } else {
            console.log('Part image API failed for:', partId, data && data.meta ? data.meta.message : 'Unknown error');
        }
    })
    .catch(error => {
        console.error('Error loading part image for', partId, ':', error);
    });
}

function toggleAllParts(itemId) {
    const selectAllButton = document.getElementById('select-all-' + itemId);
    const partCards = document.querySelectorAll('.part-card-' + itemId);
    
    // Check if all parts are currently selected
    const selectedCards = document.querySelectorAll('.part-card-' + itemId + '.selected');
    const allSelected = selectedCards.length === partCards.length;
    
    partCards.forEach(card => {
        if (allSelected) {
            // Deselect all
            card.classList.remove('selected');
            card.style.backgroundColor = 'white';
            card.style.borderColor = '#e5e7eb';
            const indicator = card.querySelector('.selection-indicator');
            const checkmark = card.querySelector('.checkmark');
            if (indicator && checkmark) {
                indicator.style.backgroundColor = 'transparent';
                indicator.style.borderColor = '#d1d5db';
                checkmark.style.display = 'none';
            }
        } else {
            // Select all
            card.classList.add('selected');
            card.style.backgroundColor = '#dbeafe';
            card.style.borderColor = '#3b82f6';
            const indicator = card.querySelector('.selection-indicator');
            const checkmark = card.querySelector('.checkmark');
            if (indicator && checkmark) {
                indicator.style.backgroundColor = '#3b82f6';
                indicator.style.borderColor = '#3b82f6';
                checkmark.style.display = 'block';
            }
        }
    });
    
    // Update button text
    const newSelectedCards = document.querySelectorAll('.part-card-' + itemId + '.selected');
    if (newSelectedCards.length === 0) {
        selectAllButton.textContent = 'Select All';
    } else if (newSelectedCards.length === partCards.length) {
        selectAllButton.textContent = 'Deselect All';
    } else {
        selectAllButton.textContent = 'Select All';
    }
    
    // Clear any error message when selecting parts
    hideErrorMessage(itemId);
}

function togglePartCard(partId, itemId) {
    const card = document.getElementById(partId + '-card');
    const indicator = card.querySelector('.selection-indicator');
    const checkmark = card.querySelector('.checkmark');
    
    if (card.classList.contains('selected')) {
        // Deselect
        card.classList.remove('selected');
        card.style.backgroundColor = 'white';
        card.style.borderColor = '#e5e7eb';
        if (indicator && checkmark) {
            indicator.style.backgroundColor = 'transparent';
            indicator.style.borderColor = '#d1d5db';
            checkmark.style.display = 'none';
        }
    } else {
        // Select
        card.classList.add('selected');
        card.style.backgroundColor = '#dbeafe';
        card.style.borderColor = '#3b82f6';
        if (indicator && checkmark) {
            indicator.style.backgroundColor = '#3b82f6';
            indicator.style.borderColor = '#3b82f6';
            checkmark.style.display = 'block';
        }
    }
    
    // Update select all button state
    updateSelectAllState(itemId);
    
    // Clear any error message when selecting parts
    const selectedCards = document.querySelectorAll('.part-card-' + itemId + '.selected');
    if (selectedCards.length > 0) {
        hideErrorMessage(itemId);
    }
}

function updateSelectAllState(itemId) {
    const selectAllButton = document.getElementById('select-all-' + itemId);
    const partCards = document.querySelectorAll('.part-card-' + itemId);
    const selectedCards = document.querySelectorAll('.part-card-' + itemId + '.selected');
    
    if (!selectAllButton || !partCards) return;
    
    // Update select all button text
    if (selectedCards.length === 0) {
        selectAllButton.textContent = 'Select All';
    } else if (selectedCards.length === partCards.length) {
        selectAllButton.textContent = 'Deselect All';
    } else {
        selectAllButton.textContent = 'Select All';
    }
}

function addMinifigAndParts(itemId) {
    const selectedCards = document.querySelectorAll('.part-card-' + itemId + '.selected');
    
    if (selectedCards.length === 0) {
        showErrorMessage(itemId, 'No minifig parts were selected. Please select at least one part.');
        return;
    }
    
    // Clear any error message
    hideErrorMessage(itemId);
    
    // Get the list ID from the search results container
    const searchResults = document.getElementById('search-results');
    const listId = searchResults ? searchResults.getAttribute('data-list-id') : null;
    
    if (!listId) {
        showErrorMessage(itemId, 'Unable to determine which list to add to. Please try again.');
        return;
    }
    
    // Collect selected parts data with pricing information
    const selectedParts = Array.from(selectedCards).map(card => {
        const partId = card.id.replace('-card', '');
        const newPriceElement = document.getElementById(partId + '-price-new');
        const usedPriceElement = document.getElementById(partId + '-price-used');
        
        // Parse prices from display text (remove $ and convert to number)
        let newPrice = 0;
        let usedPrice = 0;
        
        if (newPriceElement && newPriceElement.textContent !== 'Loading...' && newPriceElement.textContent !== 'N/A' && newPriceElement.textContent !== 'Error') {
            newPrice = parseFloat(newPriceElement.textContent.replace('$', '')) || 0;
        }
        
        if (usedPriceElement && usedPriceElement.textContent !== 'Loading...' && usedPriceElement.textContent !== 'N/A' && usedPriceElement.textContent !== 'Error') {
            usedPrice = parseFloat(usedPriceElement.textContent.replace('$', '')) || 0;
        }
        
        return {
            partNo: card.getAttribute('data-part-no'),
            partName: card.getAttribute('data-part-name'),
            quantity: parseInt(card.getAttribute('data-quantity')) || 1,
            colorId: parseInt(card.getAttribute('data-color-id')) || 0,
            itemType: card.getAttribute('data-item-type') || 'PART',
            condition: '', // Will be set from the modal
            newPrice: newPrice,
            usedPrice: usedPrice
        };
    });
    
    console.log('Preparing to show minifig details modal for:', itemId, selectedParts);
    
    // Store the minifig data for later use by the modal
    window.currentMinifigData = {
        itemId: itemId,
        listId: listId,
        selectedParts: selectedParts
    };
    
    // Show the minifig details modal
    showMinifigDetailsModal();
}

function showMinifigDetailsModal() {
    // Create the modal HTML
    const modalHtml = `
        <div class="modal-overlay" id="minifig-details-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 1000;" onclick="if(event.target === this) closeMinifigDetailsModal()">
            <div class="modal" style="background: white; border-radius: 8px; padding: 2rem; max-width: 500px; width: 90vw; max-height: 90vh; overflow-y: auto; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);">
                <h2 style="margin: 0 0 1.5rem 0; color: #374151; text-align: center;">Minifig Details</h2>
                
                <form id="minifig-details-form" onsubmit="return submitMinifigDetails(event)">
                    <div style="margin-bottom: 1rem;">
                        <label for="reference_id" style="display: block; margin-bottom: 0.5rem; font-weight: 500; color: #374151;">
                            Reference ID / Location:
                        </label>
                        <input type="text" 
                               id="reference_id" 
                               name="reference_id"
                               placeholder="e.g., Box A, Shelf 2, etc." 
                               style="width: 100%; padding: 0.75rem; border: 1px solid #d1d5db; border-radius: 6px; font-size: 0.875rem;">
                        <div style="font-size: 0.75rem; color: #6b7280; margin-top: 0.25rem;">
                            Optional: Where you store or found this minifig
                        </div>
                    </div>

                    <div style="margin-bottom: 1rem;">
                        <label for="condition" style="display: block; margin-bottom: 0.5rem; font-weight: 500; color: #374151;">
                            Condition you're trying to collect:
                        </label>
                        <select id="condition" 
                                name="condition"
                                style="width: 100%; padding: 0.75rem; border: 1px solid #d1d5db; border-radius: 6px; font-size: 0.875rem; background: white;">
                            <option value="">Select condition...</option>
                            <option value="N">New</option>
                            <option value="U">Used</option>
                        </select>
                        <div style="font-size: 0.75rem; color: #6b7280; margin-top: 0.25rem;">
                            What condition are you trying to collect for this minifig?
                        </div>
                    </div>

                    <div style="margin-bottom: 1.5rem;">
                        <label for="notes" style="display: block; margin-bottom: 0.5rem; font-weight: 500; color: #374151;">
                            Notes:
                        </label>
                        <textarea id="notes" 
                                  name="notes"
                                  rows="3"
                                  placeholder="Any notes about this minifig..." 
                                  style="width: 100%; padding: 0.75rem; border: 1px solid #d1d5db; border-radius: 6px; font-size: 0.875rem; resize: vertical;"></textarea>
                        <div style="font-size: 0.75rem; color: #6b7280; margin-top: 0.25rem;">
                            Optional: Any notes or comments about this minifig
                        </div>
                    </div>

                    <div style="display: flex; gap: 0.75rem; justify-content: flex-end;">
                        <button type="button" 
                                onclick="closeMinifigDetailsModal()"
                                style="background: #6b7280; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; font-size: 0.875rem; cursor: pointer; transition: background-color 0.2s;"
                                onmouseover="this.style.backgroundColor='#4b5563'"
                                onmouseout="this.style.backgroundColor='#6b7280'">
                            Cancel
                        </button>
                        <button type="submit"
                                style="background: #3b82f6; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; font-size: 0.875rem; cursor: pointer; transition: background-color 0.2s;"
                                onmouseover="this.style.backgroundColor='#2563eb'"
                                onmouseout="this.style.backgroundColor='#3b82f6'">
                            Add Minifig and Parts
                        </button>
                    </div>
                </form>
            </div>
        </div>
    `;
    
    // Add the modal to the document body
    document.body.insertAdjacentHTML('beforeend', modalHtml);
}

function closeMinifigDetailsModal() {
    const overlay = document.getElementById('minifig-details-overlay');
    if (overlay) {
        overlay.remove();
    }
}

function submitMinifigDetails(event) {
    event.preventDefault();
    
    const form = event.target;
    const formData = new FormData(form);
    
    // Get the stored minifig data
    const minifigData = window.currentMinifigData;
    if (!minifigData || !minifigData.itemId || !minifigData.selectedParts) {
        alert('Missing minifig data. Please try again.');
        return false;
    }
    
    // Collect form data
    const referenceId = formData.get('reference_id') || '';
    const condition = formData.get('condition') || '';
    const notes = formData.get('notes') || '';
    
    // Set condition for each part if a global condition was selected
    if (condition) {
        minifigData.selectedParts.forEach(part => {
            part.condition = condition;
        });
    }
    
    console.log('Submitting minifig with details:', {
        itemId: minifigData.itemId,
        referenceId: referenceId,
        condition: condition,
        notes: notes,
        selectedParts: minifigData.selectedParts
    });
    
    // Close the modal
    closeMinifigDetailsModal();
    
    // Disable the add button while processing
    const addButton = document.getElementById('add-minifig-' + minifigData.itemId);
    if (addButton) {
        addButton.disabled = true;
        addButton.textContent = 'Adding...';
    }
    
    // Make API call to add minifig with parts and details
    fetch('/partial-minifigs-lists/add-minifig-with-parts', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: 'list_id=' + encodeURIComponent(minifigData.listId) +
              '&minifig_id=' + encodeURIComponent(minifigData.itemId) +
              '&reference_id=' + encodeURIComponent(referenceId) +
              '&condition=' + encodeURIComponent(condition) +
              '&notes=' + encodeURIComponent(notes) +
              '&selected_parts=' + encodeURIComponent(JSON.stringify(minifigData.selectedParts))
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.text();
    })
    .then(html => {
        console.log('Successfully added minifig and parts with details');
        
        // Update the list items section with the returned HTML
        const listItemsSection = document.querySelector('[data-section="list-items"]');
        if (listItemsSection) {
            listItemsSection.innerHTML = html;
        }
        
        // Close any remaining modals
        const modalContainer = document.getElementById('modal-container');
        if (modalContainer) {
            modalContainer.innerHTML = '';
        }
        
        // Show success message
        if (typeof showNotification === 'function') {
            showNotification('Successfully added ' + minifigData.itemId + ' with ' + minifigData.selectedParts.length + ' parts to your list!', 'success');
        } else {
            alert('Successfully added ' + minifigData.itemId + ' with ' + minifigData.selectedParts.length + ' parts to your list!');
        }
    })
    .catch(error => {
        console.error('Error adding minifig and parts:', error);
        if (typeof showErrorMessage === 'function') {
            showErrorMessage(minifigData.itemId, 'Failed to add minifig and parts: ' + error.message);
        } else {
            alert('Failed to add minifig and parts: ' + error.message);
        }
    })
    .finally(() => {
        // Re-enable the button
        if (addButton) {
            addButton.disabled = false;
            addButton.textContent = 'Add Minifig and Parts';
        }
    });
    
    return false;
}

// Helper function to show notifications (fallback if not available)
function showNotification(message, type) {
    if (typeof window.showNotification === 'function') {
        window.showNotification(message, type);
    } else {
        alert(message);
    }
}

function showErrorMessage(itemId, message) {
    const errorElement = document.getElementById('error-message-' + itemId);
    if (errorElement) {
        errorElement.textContent = message;
        errorElement.style.display = 'block';
    }
}

function hideErrorMessage(itemId) {
    const errorElement = document.getElementById('error-message-' + itemId);
    if (errorElement) {
        errorElement.style.display = 'none';
    }
}

function loadPartPricing(partId, itemType, partNo, colorId, quantity, itemId) {
    console.log('Loading part pricing:', partId, itemType, partNo, colorId, quantity);
    
    // Load both new and used pricing in parallel
    Promise.all([
        loadPartPricingByCondition(partId, itemType, partNo, colorId, 'N'),
        loadPartPricingByCondition(partId, itemType, partNo, colorId, 'U')
    ])
    .then(([newPrice, usedPrice]) => {
        const priceNewElement = document.getElementById(partId + '-price-new');
        const priceUsedElement = document.getElementById(partId + '-price-used');
        
        // Update individual part pricing display
        if (newPrice !== null && !isNaN(newPrice)) {
            priceNewElement.textContent = '$' + newPrice.toFixed(2);
        } else {
            priceNewElement.textContent = 'N/A';
        }
        
        if (usedPrice !== null && !isNaN(usedPrice)) {
            priceUsedElement.textContent = '$' + usedPrice.toFixed(2);
        } else {
            priceUsedElement.textContent = 'N/A';
        }
        
        // Update part out values
        updatePartOutValues(itemId, newPrice, usedPrice, parseInt(quantity));
        
        console.log('Part pricing loaded - New:', newPrice, 'Used:', usedPrice);
    })
    .catch(error => {
        console.error('Error loading part pricing:', error);
        const priceNewElement = document.getElementById(partId + '-price-new');
        const priceUsedElement = document.getElementById(partId + '-price-used');
        if (priceNewElement) priceNewElement.textContent = 'Error';
        if (priceUsedElement) priceUsedElement.textContent = 'Error';
    });
}

function loadPartPricingByCondition(partId, itemType, partNo, colorId, condition) {
    console.log('Loading part pricing for condition:', condition, partId, itemType, partNo, colorId);
    
    return fetch('/partial-minifigs-lists/part-pricing', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: 'item_type=' + encodeURIComponent(itemType) + 
              '&item_id=' + encodeURIComponent(partNo) + 
              '&color_id=' + encodeURIComponent(colorId) + 
              '&condition=' + encodeURIComponent(condition)
    })
    .then(response => {
        console.log('Part pricing response status:', response.status, 'for condition:', condition);
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.json();
    })
    .then(data => {
        console.log('Part pricing API response for condition', condition, ':', data);
        
        // Check if API call was successful
        if (data && data.meta && data.meta.code === 200 && data.data) {
            // Handle both array and single object responses
            let priceItems = Array.isArray(data.data) ? data.data : [data.data];
            
            // Extract price from the first item (should match our condition)
            if (priceItems.length > 0) {
                const priceItem = priceItems[0];
                const avgPrice = priceItem.avg_price || priceItem.average_price || priceItem.price;
                
                if (avgPrice) {
                    const price = parseFloat(avgPrice);
                    console.log('Found part', condition === 'N' ? 'new' : 'used', 'price:', price);
                    return price;
                }
            }
        } else {
            const errorMsg = data && data.meta ? data.meta.message : 'Unknown error';
            console.log('Part pricing API error for condition', condition, ':', errorMsg);
        }
        
        return null;
    })
    .catch(error => {
        console.error('Error loading part pricing for condition', condition, ':', error);
        console.error('Request details - itemType:', itemType, 'partNo:', partNo, 'colorId:', colorId, 'condition:', condition);
        return null;
    });
}

function updatePartOutValues(itemId, newPrice, usedPrice, quantity) {
    // Initialize if not exists
    if (!window.partOutValues || !window.partOutValues[itemId]) {
        window.partOutValues = window.partOutValues || {};
        window.partOutValues[itemId] = {
            newTotal: 0,
            usedTotal: 0,
            partsLoaded: 0,
            totalParts: 0
        };
    }
    
    const partOutData = window.partOutValues[itemId];
    
    // Add to totals (multiply by quantity)
    if (newPrice !== null && !isNaN(newPrice)) {
        partOutData.newTotal += newPrice * quantity;
    }
    if (usedPrice !== null && !isNaN(usedPrice)) {
        partOutData.usedTotal += usedPrice * quantity;
    }
    
    partOutData.partsLoaded++;
    
    // Update display
    const partOutNewElement = document.getElementById('partout-new-' + itemId);
    const partOutUsedElement = document.getElementById('partout-used-' + itemId);
    
    if (partOutNewElement) {
        partOutNewElement.textContent = '$' + partOutData.newTotal.toFixed(2);
    }
    if (partOutUsedElement) {
        partOutUsedElement.textContent = '$' + partOutData.usedTotal.toFixed(2);
    }
    
    console.log('Part out values updated for', itemId, ':', partOutData);
}

// Auto-load details when template loads
function initializeBricklinkItem(itemId) {
    if (itemId) {
        loadMinifigDetails(itemId);
    }
}
</script>
{{end}}